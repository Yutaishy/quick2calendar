# 学びと気づきログ

## 2026-02-14
- ユーザー向けUXでは、OAuth Client ID/Secret の手入力は不自然で離脱要因になる。"Googleを接続" ボタン中心の導線に統一する。
- 開発時のOAuth設定は、設定画面入力ではなく同梱設定ファイル（`oauth-client.local.json`）または環境変数で注入する方が運用しやすい。
- Node実行環境は一時的なローカル展開より、Homebrew + Volta の恒久運用が再現性と保守性に優れる。
- `~/.zshrc` 更新時は上書き禁止。誤記行のみ除去し、必要行のみ追記する。
- AGENTS.md の指示（学びを必ずテキスト記録）を作業フローに組み込み、各実装フェーズ後に記録更新を行う。
- OAuth設定の探索先は開発時と配布後で異なるため、`src` 相対パス固定ではなく `process.cwd` / `app.getAppPath` / `process.resourcesPath` を候補に持たせる。
- 設定画面は「接続操作」と「内部構成状態の表示」に責務を絞ると、ユーザー向け操作コストを下げつつトラブルシュート情報も維持できる。
- アプリ名確定時は、表示文言だけでなく `package名` / `APP_ID` / `Application Support` 保存先も同時に揃えると運用時の混乱を防げる。
- 公開審査を見据える場合、`calendar.events` 単独へスコープ最小化する判断が有効。意図は「不要権限要求による審査差し戻し」を防ぐことと、説明責任を単純化すること。
- 連携解除時はローカル削除のみだと「データ削除方針」の説明が弱くなるため、Googleのトークン失効APIを呼ぶ実装へ変更。意図はユーザー主導でアクセスを即時停止できる設計を示すこと。
- 審査情報は会話ベースで管理すると漏れやすい。`review/release-metadata.local.json` と `npm run check:review` を用意し、提出前に機械的に不足を検知できる体制にした。判断理由は、審査落ちの主因が「情報不整合」であるため。
- `check:review:strict` を追加し、警告（例: example値残存）でも失敗扱いにできるようにした。意図は「提出直前に曖昧な暫定値が混入する事故」を防ぐこと。
- 審査準備の実作業を止めないため、法務文書（privacy/terms/data deletion）の下書きをリポジトリ内にテンプレ化した。意図は「URL先の本文未整備」による審査停滞を早期に回避すること。

## 2026-02-15
- Google Cloud Console からダウンロードした `client_secret_*.json` は、そのままアプリ設定で使わず `app/oauth-client.local.json` へ正規化して反映する運用に統一した。理由は、アプリ実装側の参照フォーマット（`clientId/clientSecret/redirectUri`）と一致させ、設定ミスを減らすため。
- CLI からの `npm start` で Electron が `SIGABRT` になるケースは、実装不備ではなく GUI 実行コンテキストの制約（WindowServer/セッション差異）で発生しうると確認した。今後は「コード健全性は `npm run check`、UI起動確認は通常ログイン中のmacOSセッション」で分離して検証する。
- 設定ウィンドウが「無反応」に見えるときは、イベント未発火だけでなく「表示はされているが前面化されていない／最小化状態」の可能性が高い。`showSettingsWindow` で `restore + moveTop + focus` を明示し、さらにクリック側で成功/失敗メッセージを出すと、ユーザーが状態を判断しやすくなる。
- 日時パーサで `new Date()` の汎用解釈を先に使うと、`2/20 19:00` が 2001年扱いになるなど意図しない補完が発生する。先に明示フォーマット（`YYYY-M-D`/`M-D`/`今日|明日`）で厳密に解釈し、日付成分一致チェックでロールオーバー（例: 2/31 -> 3/3）を弾く実装にした。
- `今日/明日` の語は正規化で `日` を除去すると壊れるため、相対日付判定は「日本語語彙を壊す変換」の前に行う必要がある。意図は、自然言語入力の主要ケースを安定して通すこと。
- ガラス調UIはCSSだけでは成立せず、Electron側で `transparent + vibrancy + backgroundColor` を同時に設定して初めて期待どおりの透明感になる。見た目要件はレンダラとメインプロセスの両方を揃えて検証する運用にした。
- 対話確認の `yes/no` 判定で単一文字の `includes` 判定を使うと誤判定が起きる（例: 英単語内の `n`）。単語境界と日本語語彙を分けて判定し、誤キャンセルを防ぐ設計へ変更した。
- 再発防止のため、今回の日時バグを `scripts/check-date-parsing.mjs` で回帰チェック化し、`npm run check` に組み込んだ。意図は「目視確認頼み」を避け、変更時に機械的に破壊検知すること。
- `quickApi` 未定義エラーは、Renderer側のボタン実装より前に「Preload橋渡しの成立条件（sandbox設定など）」を確認するのが先。Electronの `webPreferences` を固定化し、Preloadの構文チェックを `npm run check` に含めると原因切り分けが早くなる。
- 「無色透明のガラス調」は白半透明量が多いと灰色に見える。`panel/input/button` のアルファを下げ、`settings-body` の下地色を透明にすることで、背景を透かした見え方に近づく。
- Electron本体をESMで運用していても、Preloadは `.cjs` + `require("electron")` へ寄せると bridge 生成失敗を回避しやすい。今回の `window.quickApi` 未定義はこの境界で起きていた可能性が高く、Preloadの実行方式を明示して安定化した。
- 「グレーに見える」問題は、ガラス感の本質が blur だけでなく「上に乗る塗りの濃度」にある。`panel/input/button` の alpha を 0.06〜0.12 まで落とすことで、無色透明寄りの見え方に寄せられた。
- `window.quickApi` 未定義が継続する場合、Preloadのファイル形式が実行方式と噛み合っていない可能性がある。`preload-*.cjs` へ切り替え、`BrowserWindow.webPreferences.preload` 参照も `.cjs` に揃えることで bridge の不整合リスクを下げられる。
- ガラス調の見た目はアプリ側調整だけでなくOS設定に依存する。macOSの「透明度を下げる」が有効だと意図的にグレー化されるため、UI要件として事前に明記する必要がある。
- OAuthリダイレクトのエラーページで `Content-Type: text/html; charset=UTF-8` を明示しないと日本語が文字化けする。成功時だけでなく失敗時レスポンスにも同じヘッダを付与する必要がある。
- OAuthの `state` 検証失敗は実装バグだけでなく「認証ボタン連打・複数タブ」でも発生する。Renderer/メイン双方で「認証進行中の多重実行を拒否」することで再発を防げる。
- モデル設定を自由入力だけにすると入力ミスで実行時エラーが起きやすい。UIを「プリセット選択 + カスタム入力」の二段構えにすると、通常運用の誤入力を減らしつつ将来モデルへ追従できる。
- ガラスUIで「箱の中に箱」感が出る主因は、内側カード（背景+枠）と入力欄（背景+枠）の二重レイヤー。外側の一枚板だけに視覚要素を集約し、内側は透明化するとシングルレイヤーに見える。
- テキスト入力を背景に直接置くデザインでは、`textarea` の枠・塗りを消すだけでなく、clarification領域の枠も同時に外さないと統一感が崩れる。
- 最小入力UIでは、操作導線を増やすより「入力テキストに視線を集中させる」方が有効。ヘッダー文言・設定ボタン・送信ボタンを視界から外し、Enter送信を前提にすると認知負荷が下がる。
- 透明度を上げすぎると情報は減っても可読性が落ちる。入力集中用途では、単一レイヤーは維持しつつ背景はやや不透明（暗め）にした方が視認性と没入感のバランスが良い。
- 透明度を最大化する要件では、`rgba` の半透明塗りを残すと意図に反する。`quick-body` は `background: transparent` + `border: 0` + `box-shadow: none` にし、質感は `backdrop-filter` のみで表現するのが最短。
- 「無色透明」を厳密に実現するには、CSSだけでなくElectronウィンドウ側の `vibrancy` も無効化する必要がある。`vibrancy` は透明背景でもシステム側の色付き質感を加えるため、要求と矛盾する場合は外す。
- 完全透明UIでも操作性のために最小限の境界は必要。外枠を 1px の低コントラスト線で残すと、無色透明の印象を壊さずに視認性だけ改善できる。
- 透明UIの可読性を上げるには、背景塗りを増やすより「光沢ハイライト（擬似要素）+ 微弱な内側ライン」を重ねる方が、透明感を維持したまま認識性を上げやすい。
- モデル選択肢が少ないと、実運用での比較検証（品質/速度/コスト）がやりにくい。静的HTMLのoption列挙ではなく、JS側のプリセット配列から生成する方式にすると、将来モデル追加時の保守コストを下げられる。
- ユーザーが「3.0モデルが見当たらない」と迷うのは、API実名（`gemini-3-...-preview`）と世代呼称（3.0）がUI上で結びついていないため。設定画面の表示ラベルに「Gemini 3.0」を明示し、READMEも同時更新して認知ギャップを減らす。
- macOSの入力ショートカット（`Cmd+V` など）は、Electronで独自メニューだけを置くと効かなくなる場合がある。設定画面での貼り付け不全は実装側のキー処理ではなく、アプリメニューに `編集` ロール（paste含む）が欠けていたことが原因だった。今後はショートカット不具合を見たら、まずメニューのrole構成を確認する。
- 自然文日時の取りこぼし（例: `明日五時からご飯`）を防ぐには、Gemini依存だけでなくローカルパーサ側も漢数字・文中表現を扱えるようにしておく必要がある。今回は `parseFlexibleDateTime` を文中マッチ対応に拡張し、`parseDirectInput` でも全文推定を使うようにした。副作用としてタイトル抽出が `予定` に寄る退行が出たため、`stripLeadingSchedulePrefix` ベースの抽出に戻して回帰チェックへ追加した。
- 「確認入力」フェーズで日時パースに失敗した場合、従来は固定フォーマット再入力を要求していたが、`aiEnabled=true` なら Gemini で再解釈する余地がある。`missing_start/missing_end/invalid_time_range` に再解釈フォールバックを入れることで、ユーザーに同じ文を言い換えさせる回数を減らせる。
- ユーザー要件が「Geminiを必ず経由した解釈」である場合、`auto/direct` の併存は柔軟性ではなく挙動の不一致を生む。`SchedulerService` を Gemini必須フローに単純化し、Gemini失敗時は即エラー返却にした方が運用意図と一致する。
- 設定画面の項目過多は運用ミスより先に「何を触ればいいか分からない」状態を作る。今回、設定を「Google接続」「Geminiキー/モデル」「カスタム指示」の3ブロックに絞り、内部互換は維持しつつ操作面を最小化した。
- Frameless + 透明UIでは、表示テキスト（status/確認文）が選択しづらく「エラーメッセージを共有できない」問題が起きる。`user-select: text` を明示し、さらに `Cmd+C` 補助（選択なしでも現在のstatusをコピー）をIPC経由で用意すると、運用時の問い合わせ共有が安定する。
- Gemini必須運用では、API遅延時の待ちっぱなしがそのまま「アプリ無反応」に見える。`fetch` にAbortControllerベースの明示タイムアウトを入れて、待機上限と失敗理由をユーザーへ返す設計が必要。
- Gemini再解釈の戻り値はタイムゾーン付きISOになることがある。確認回答の補完で `parseFlexibleDateTime` だけに依存すると取りこぼすため、`toDate` + `formatLocalDateTime` のフォールバックで吸収する方が実運用で安定する。
- クイック入力で `Enter` を送信に割り当てると、ユーザー視点では「送信ボタンを押していないのに実行された」体験になりやすい。自然文メモ入力主体のUIでは、`Enter=改行`、`Cmd+Enter=送信` が誤送信を減らせる。
- Geminiモデルは時期によって廃止/非対応が起きるため、保存済みモデルが404になるケースがある。`model not found` のとき既定モデルへ1回フォールバックする実装を入れると、設定が古いユーザーでも操作を継続しやすい。
- 日本語IMEの変換確定で押す `Enter` は、実装によっては送信ショートカットと衝突する。`event.isComposing` / `keyCode===229` を除外しないと「1文字入力しただけで送信された」ような誤動作に見える。
- 開発中のElectron実行（未パッケージ）で `app.setLoginItemSettings` を呼ぶと、macOS側で `Operation not permitted` ログが出ることがある。自動起動を使わない運用では `launchAtLogin=false` を固定し、未パッケージ時は login item API を呼ばないのが安全。
- Gemini必須フローでも、モデルが開始時刻を空で返すケースは発生する。`sourceText` に最低限の日時手がかりがある場合（例: `あしたごじ`）は、ローカル正規化（ひらがな -> 明日/5時）で開始時刻を補完すると、不要な再質問を減らせる。
- 要件が「解釈はGeminiに一元化」の場合、ローカル補完ロジックは一時的に改善しても設計意図から外れる。不足項目は Gemini 再補完（内部リトライ）で埋める構成に戻し、ローカル解析の追加は行わない方が運用方針と一致する。
- Gemini APIのタイムアウト値が短すぎると、モデル負荷や回線遅延時に実力以前で失敗する。待機上限を長めに取り（今回は90秒）、AbortError時に1回だけ再試行を入れると、失敗率を下げつつ無限待ちも防げる。

## 2026-02-16
- 「成功トーストは出るがカレンダーに見えない」問題は、ユーザー側で現象を再現できても開発側がトレースできないと調査が止まる。`main/scheduler/gemini/calendar` を横断した構造化ログ（JSONL）を `Application Support` に出す設計にし、どこでズレたかを時系列で追えるようにした。
- 追跡可能性を上げるには、ログをファイルに出すだけでは不十分。設定画面から「ログパス表示・再読み込み・ファイルを開く」を直接提供し、CLIに不慣れでも自己診断できる導線を同時に用意する必要がある。
- 「明日」のような相対日時は、モデルに現在日時を明示しないと過去年を返す場合がある。Geminiプロンプトに実行時のローカル日時を基準として埋め込むことで、年ズレによる“登録したのに見えない”事象を減らせる。
- framelessの入力UIは全体をドラッグ領域にするとテキスト入力を阻害しやすい。最小の専用ドラッグハンドルを上部に置く方式にすると、移動性と入力操作性を両立しやすい。
- 「一枚板デザイン維持」を優先する場合、ドラッグハンドルの可視要素はノイズになる。`body` を drag 領域にし、入力/ボタンだけ `no-drag` に分離すると、見た目を崩さず移動操作を残せる。
- ウィンドウを約2/3に縮小すると既存のタイポ/余白だと密度が高すぎるため、入力欄の `min-height` と `font-size`、外周 `padding` を同時に下げると、詰まり感を抑えてバランスを維持しやすい。
- Electronでは `target="_blank"` のリンクは環境によってアプリ内挙動になり遷移しないことがある。確実に外部遷移させるには、RendererのクリックをIPC経由で `shell.openExternal` に委譲する方が安定する。
- 「他アプリに切り替えても前面維持」の要件では、`alwaysOnTop` だけでなく `blur時にhide` していないかの確認が必須。自動非表示フックが残っていると要件に反するため、先に除去するべき。
- 黒曜石ガラスの視認性は、単純な黒背景より「暗色グラデーション + 弱いハイライト + 内側の光沢線」の組み合わせの方が、情報量を保ったまま高コントラスト化しやすい。
- 前面固定ウィンドウで「起動直後に消える」挙動が出る場合、`hide` イベントを監視して意図しない非表示を即再表示する保険が有効。設定画面表示や明示非表示だけ例外フラグで許可すると、通常運用の安定性を上げられる。
- Raycast Noteのような常時前面を狙うなら、`alwaysOnTop` レベルを `screen-saver` に上げるだけでなく、`setVisibleOnAllWorkspaces(visibleOnFullScreen=true)` と再ピン留め（show/focus/blur）を組み合わせると、アプリ切替やSpace移動時の背面落ちを抑えやすい。
- `setVisibleOnAllWorkspaces` で `skipTransformProcessType: true` を付けると、環境によってはSpace跨ぎ表示が期待通りにならない場合がある。常時前面重視ならオプションを外して標準変換に任せた方が安定しやすい。
- 小型ウィンドウでは、成功後に`status + resultLink + actions`が増えると下端が見切れやすい。入力欄を固定高にせず `flex: 1` で可変にすると、機能表示を保ったまま見切れを防げる。
- 小型ウィンドウでドラッグ不能になる典型は、全体を占有するコンテナが `no-drag` 扱いになっているケース。`form` コンテナ自体を `drag` にし、入力/リンク/ボタンだけ `no-drag` に明示すると、見た目を変えず操作性を回復できる。
- 長文入力時の視認性と操作性を両立するには、ウィンドウ全体を伸ばすより `textarea` 内部だけスクロールさせる方が安定する。スクロールバーは非表示（`scrollbar-width: none` + `::-webkit-scrollbar { width: 0; }`）でも、トラックパッド操作は維持できる。
- 「一枚板の見た目」を維持したままドラッグ性を確保するには、可視ハンドルではなく不可視の上部ドラッグゾーンを置く方式が有効。見た目ノイズを増やさず、長文時のドラッグ不能を回避できる。
- 小型レイアウトで「上部見切れ + ドラッグ不能」が同時に出る場合、`form` に `height: 100%` を持たせたまま上部ドラッグゾーンを追加していることが原因になりやすい。`form` 高さ固定を外して `flex: 1` のみにし、入力欄を可変縮小させるのが安定。
- 送信後だけ情報量が増えるUI（status + link + action）は、通常時の高さ最適化だけでは破綻する。`has-result-link` のような状態クラスで入力欄の最小高を段階的に下げると、見切れを抑えやすい。
- 「送信後に前入力が消える」設計のままではスクロール体験を改善できない。Chat Bar風にするなら、入力欄と履歴領域を分離し、送信内容を上部の会話リストへ積む構造へ切り替える必要がある。
- コンパニオン型の小窓UIでは、右スクロールバーを隠してもトラックパッド操作は維持できる。`overflow-y: auto` とスクロールバー非表示を会話リストへ適用すると、見た目を維持しつつ可観測性を確保できる。
- frameless + draggable領域では、親が `drag` のままだとトラックパッドスクロールが奪われることがある。会話リスト配下を `no-drag` に明示し、必要なら `wheel` を捕捉して `scrollTop` へ流すとスクロール操作が安定する。
- 初期の説明テキストは、小窓型入力UIではガイダンスよりノイズになりやすい。空状態から直接入力できる方が操作速度と視認性の両方で有利。
- スクロール不能が残る場合は、`no-drag` を子要素だけでなく親コンテナ（`body`/`shell`）まで徹底する必要がある。`drag` は専用ゾーンに限定しないと、会話バブル上のホイール入力がOSドラッグ判定に吸われる。
- `height: 100%` 系レイアウトは `html/body` の高さ定義が欠けると機能しない。スクロールコンテナを確実に成立させるには `html, body` まで `height: 100%` を通すのが必須。
- ドラッグ領域を中央コンテンツ上に置くと、スクロール・選択・クリックのどれかを必ず阻害しやすい。解決策は「見えないハンドル」ではなく、四辺と四隅の最小フレームだけを `-webkit-app-region: drag` にすること。これで視認性を保ったまま、下部までスクロールした状態でも移動操作を継続できる。
- 小窓UIで入力欄がスクロール領域を圧迫する問題は、CSS調整だけでは限界がある。RendererからMainへ高さ変更IPCを持たせ、入力開始時にウィンドウ自体を拡張する実装にすると、情報量が増えても可読性を保ちやすい。
- 高さ拡張の状態をRendererだけで持つと、次回表示時に同期ズレが起きる。`quick:focus` 受信時に拡張フラグをリセットし、表示開始時はMain側で既定サイズへ戻す設計にすると、毎回同じ初期挙動を保証できる。
- 「入力した瞬間に拡張」は意図しない視覚ノイズになりやすい。拡張のトリガーは `input` ではなく「最初の送信操作」に寄せると、入力準備中の安定した視界を維持しつつ、必要なタイミングだけ表示領域を増やせる。
- ガラスUIが「二重コンテナ」に見える主要因は、`border` と `::after` の inset 枠が同時に存在すること。外枠は1本だけ残し、光沢は `::before` に集約すると、一枚板の印象を保ったまま視認性を維持できる。
- 日本語IMEの変換候補がコンテナに隠れる場合、`overflow: hidden` がクリッピング原因になりやすい。入力領域を含む最上位コンテナを `overflow: visible` にすると、候補パネルがはみ出しても視認できるようになる。
- IME候補がまだ見切れる場合、ウィンドウ仕様を変えるより「変換中だけ下部余白を確保」する方がUX影響が小さい。`compositionstart/end` でクラスを切り替え、候補表示中だけフォーム下部に安全余白を追加すると、常時のレイアウトは維持したまま候補の視認性を改善できる。
- Electronの最前面レベルを `screen-saver` に固定すると、環境によってはIME候補が背面化することがある。IME変換中だけ前面レベルを `floating` に一時切り替え、終了時に `screen-saver` へ戻すと、常時前面要件を維持しつつ候補表示の被りを避けやすい。
- IME候補対策でレイアウト余白を動かすと、入力中にテキスト領域が上下して違和感が出る。常用UXを優先する場合は、見た目を動かすCSSは撤去し、IME中の前面レベル制御だけ残す方が体験が安定する。
- クイック入力を表示した直後にフォーカスが不安定になる場合、`show -> focus -> renderer focus` の1回呼び出しだけでは取りこぼすことがある。Main側で `app.focus({ steal: true })` と `show` 時の再通知を入れ、Renderer側で短時間のフォーカス再試行を行うと「最初のクリックが必要」な状態を解消しやすい。
- それでも初回クリックが必要な端末では、Main側でも短時間の再フォーカス（複数遅延リトライ）を持つ必要がある。`show` 直後の1回だけでなく、数百ms内で `app.focus + window.focus + webContents.focus + quick:focus` を再実行すると安定しやすい。
- ショートカット挙動をRaycast風にするなら「開く専用」ではなくトグルが必要。`show/hide` を同じ経路で切り替える `toggleQuickWindow` を中心にし、`hide` 処理を共通化すると、ショートカット・メニュー・IPCで挙動を揃えられる。
- 「隠した直後に再表示される」現象は、`hide` 監視の自己回復ロジックが意図的な `hide` と区別できていないのが原因。次回の `hide` 回復だけ無効化する `suppressNextHideRecovery` のような単発フラグを入れると、常時復旧保険を維持したままトグル挙動を壊さずに済む。
- 表示直後フォーカスの再試行タイマーを入れている場合、非表示にする直前にそのタイマーを必ず全キャンセルしないと、残タイマーで再表示される競合が起きる。`show` 前後でタイマー管理を一元化し、`hide` でクリアするのが安全。
- それでも「1回目だけ再表示」する場合は、`app.on("activate")` が非表示直後に発火している可能性がある。意図的に隠した直後だけ `activate` による `show` を1回抑止するガード（`suppressNextActivateShow`）を入れると、Raycast型トグルに近い挙動になる。
- グローバルショートカットは環境によって短時間に複数回発火することがある。トグル系UIでは `220ms` 程度のデバウンスを入れて、1回押下で `hide->show` が連続しないようにするのが有効。
- トグル挙動の安定化には「今このウィンドウは表示されるべきか」の状態管理が必要。`quickWindowShouldBeVisible` を基準に `hide` 自己回復と `activate` 再表示を条件化し、手動で隠した直後だけ再オープンをガードすると、1回目だけ再表示される競合を抑えられる。
- `globalShortcut` とメニュー側 `accelerator` に同じキーを設定すると、アクティブ状態で二重にトグルが走る場合がある。トグル系の本命は `globalShortcut` に一本化し、メニュー側はアクセラレータ無しにすると競合を減らせる。
- `hide` 自己回復の `setTimeout` を無管理で残すと、手動 `hide` の直後に古い再表示予約が走って「1回目だけ戻る」現象を起こしうる。回復タイマーIDを保持し、`show/hide` の入口で常にキャンセルする必要がある。
- `focus` ヘルパー内で非表示時に `show()` してしまう設計は、残存タイマーや遅延フォーカスから再表示を誘発する。`show` は `showQuickWindow` だけの責務に固定し、`focus` は「表示中のウィンドウのみ対象」に分離するのが安全。
- それでも再発する場合は、グローバルショートカットのキーリピート相当をロックで吸収する必要がある。`toggle` 入口に短時間ロック（例: 700ms）を入れると、1回押下中の多重コールで `hide->show` になる競合を抑えられる。
- 自己回復タイマーをキャンセルしていても、タイマーコールバック実行中の競合は残る。回復コールバックの内部で `quickWindowShouldBeVisible` を最終確認し、意図的に隠した状態では `show()` を絶対に呼ばないガードが必要。
- Raycast型トグルを最優先する場合、`hide` 時の自動復帰ロジック自体が設計衝突を起こす。短期安定化では自己回復を撤去し、表示は `toggle/show` ルートのみに限定する方が再表示バグを根絶しやすい。
- 修正後も症状が変わらないときは、旧Electronプロセスが生存して新コードが読まれていないケースを先に疑う。`pgrep/ps` で実行中プロセスを確認し、対象を停止してから再起動しないと静的修正が反映されない。
- さらに再表示が残る場合、`app.on("activate")` で hidden 状態から `showQuickWindow` を呼ぶ仕様自体がトグル要件と衝突する。Raycast型に合わせるなら `activate` は「表示中ウィンドウの再フォーカスのみ」に限定し、hidden 状態では何もしない方が挙動が安定する。
- ショートカット由来のキーリピートは、`hide` 後の再オープン抑止時間が短いとすり抜ける。再オープンガードは長めに取り、かつ `hide` の記録は `toggle` 起点に限定しないと、設定遷移など別経路まで巻き込んで副作用が出る。
- 抜本対応としては、時間ベースのデバウンスを積み増すより「キー解放待ちガード」の状態機械に置き換える方が再現性高く効く。ショートカット経路だけ `quickShortcutAwaitRelease` を持ち、`hide` 後は同一押下中のコールを無視し、一定時間コールが止まった時点でのみ再トグルを許可すると、`1回目だけ hide->show` の揺れを論理的に防げる。
- 「1回目ショートカットで hide 後すぐ再表示、2回目で隠れる」現象は、ショートカット多重発火だけでなく `hide` 中に走る `blur` 処理が hidden ウィンドウへ最前面ピンを再適用している競合でも再現しうる。`pinQuickWindowOnTop` を「表示中のみ実行」に限定し、`blur` 側も `isVisible()` ガードを入れることで、非表示状態への副作用を遮断した。
- `allowQuickWindowHide` を `hide()` 直後に即解除すると、非同期で遅れて来る `blur` が通常経路として扱われる。解除タイミングを `hide` イベントへ移し、隠す遷移中のイベントだけ確実に抑止する設計にすると、トグル挙動が安定する。
- グローバルショートカットは環境により同一押下内で複数コールされる前提で扱うべき。可視/不可視条件つきガードだと取りこぼすため、ショートカット入口を「ガード中は無条件で無視」に単純化し、1押下=1トグルの状態機械へ寄せた方が再発しにくい。
- ショートカット設定は手入力欄より「記録ボタン -> 実際にキーを押す」方式の方が、Electronアクセラレータ記法を知らないユーザーでも失敗しにくい。設定UIは Raycast 型の操作モデル（待機中状態を明示して1操作で登録完了）に寄せると学習コストを下げられる。
- ショートカット登録は全設定の一括保存に混ぜると意図しない項目まで保存されるリスクがある。`saveSettings({ shortcut })` の部分更新で即反映すると、他項目の未保存編集中でも安全にホットキーだけ変更できる。
- macOSで `Option + 文字` をショートカット登録すると `event.key` が記号やダイアクリティカル文字に変わり、文字判定ベース実装では取りこぼす。ショートカット収集は `event.key` より `event.code` を優先し、物理キー起点でアクセラレータへ変換する方が安定する。
- 設定UIのショートカット表示は「読める最小サイズ」を超えて大きくすると作業ノイズになる。表示専用入力欄の固定幅を絞り、ボタンも小型化して1行密度を上げると、設定画面全体の視認性を損なわずに操作性を保てる。
- 画像添付を予定抽出に使う場合、OCRを別APIに分離しなくても Gemini `generateContent` の `inlineData` へ画像を直接渡す構成で十分に成立する。既存のJSON抽出フローを再利用できるため、実装差分を最小に抑えられる。
- 画像入力はRendererで無制限にbase64化すると不安定になりやすい。件数・単体サイズ・合計サイズの上限をRenderer/Main/Gemini送信前で多段チェックする方が運用時の失敗原因を明確化できる。
- 画像添付機能はUI説明を増やしすぎると入力集中体験を壊す。クイック入力では「小さい添付ボタン + 件数表示 + クリア」だけに留め、詳細制約はREADMEに寄せる構成がバランスよい。
- 画像を初回入力と確認回答で結合する場合、結合上限をGemini側許容量（今回は3件）と揃えないと、確認フェーズでのみ上限エラーが出る。UI上限・セッション結合上限・API送信上限は同一値で管理する方が事故が少ない。
- クイック入力の見た目を洗練させる際は、外枠ガラスを維持したまま「会話領域 + 下部Composer」の2層に整理すると、ChatGPTデスクトップに近い視線誘導を作りやすい。機能追加をせずに余白・角丸・陰影の階調を揃えるだけでも体感品質が大きく上がる。
- グローバル向けのミニComposerでは、操作ラベル文字（例: 画像/送信/クリア）を直接見せるより、アイコンのみ + `aria-label` で意味を持たせる方が言語依存を減らせる。見た目をChatGPT Mac版に寄せる場合も、可視テキストは会話内容へ集中させ、操作は記号化した方がUI密度が上がる。
- 実装全体を読むと、責務分離は `main(ウィンドウ/IPC)`・`scheduler(状態機械)`・`gemini/google client(外部API)`・`renderer(UI)` で明確に保たれており、機能追加時はこの層を跨いで直書きせず、既存の境界（IPCとService）を守る方が副作用を抑えやすい。
- 運用上の最重要リスクは「OAuthシークレット実ファイルの置き場所」と「審査メタデータの暫定値残存」の2点。`.gitignore` で除外されていても、共有ディレクトリ運用では誤配布経路が残るため、提出前チェック（`check:review:strict`）と機密ローテーション手順をセットで回す必要がある。
- デザイン指示が実装メモにだけ存在すると、開発中に「見た目は好みで変えてよい要素」と誤解されやすい。`デザインUX.md` の内容は `要件定義.md` の FR/NFR/受け入れ基準へ写像し、テスト可能な仕様として固定する方が、UI改修時のブレを防げる。
- Pill型UIを実装する際、履歴領域を常時表示すると「上段=入力欄」の要件と衝突する。履歴は `has-history` 状態でのみ表示し、空状態は入力欄+ツールバーだけ見せると、デザイン要件と会話機能を両立しやすい。
- 送信ボタンの見た目を「常時押せそう」にすると誤操作が増える。`loading` だけでなく「入力または添付があるときのみ有効」に連動させると、視覚仕様（Disabledっぽい状態）と操作UXを一致させられる。
- Pill型の印象は角丸だけでなく「横長比率」で決まるため、ウィンドウ寸法も同時に調整しないと見た目が崩れる。今回は `quick window` を横長・低めへ寄せることで、同じスタイルでも意図した質感に近づけられた。
- UI改善で最優先すべきは「機能しないように見える要素の排除」。今回は添付クリア用の副ボタンと会話バブル表現を外し、`入力欄 + 左の添付 + 右の送信` の3要素へ収束させることで、視覚ノイズと誤解を同時に減らせた。
- ChatGPTデスクトップの `Option + Space` 体験に寄せる場合、入力中や送信時にウィンドウ自体が拡張する挙動はUXノイズになる。拡張IPC呼び出しを撤去し、テキストエリアを1行起点の固定コンパクト設計にすると、期待とのズレを減らせる。
- UI調整時に対話履歴レイヤーまで削ると、見た目はシンプルでもプロダクトの中核体験（聞き返しを含むチャット連続性）を壊してしまう。今回の再修正で「対話履歴は維持、不要な補助ボタンだけ削る」という境界を明確化した。
- ウィンドウの表示状態（Expanded/Collapsed）を `show` のたびにリセットすると、ユーザーが意図したコンテキスト（会話履歴など）が失われたように感じられる。特にランチャー型アプリでは、非表示＝終了ではなく、一時的な退避として扱われることが多いため、セッション状態の維持が重要である。
- Electronの `app.focus({ steal: true })` は、OSのSpace遷移を引き起こす副作用があるため、オーバーレイ型アプリでは使用を避けるべき。
- 「ガラス調UI」において、外枠と中身の間にパディングを設けると、透過効果によって重なりが可視化され「ズレた2枚の板」に見えてしまう。一枚板の質感を出すには、最上位コンテナ（`quick-body`）だけに背景と境界線を持たせ、内部パディングは `0` にし、コンテンツ側のパディングで余白を調整する必要がある。
- ガラスの質感を高めるには、単一の半透明色ではなく、`linear-gradient` を用いて上部から光が当たっているような微妙なグラデーションを作ると効果的。また、`border-top` を明るく、`border-bottom` を暗くし、`inset` シャドウで上端にハイライトを入れることで、板としての厚みと立体感を表現できる。
- また、`box-shadow: inset` によるハイライトは、デザインによっては「内側の別の板の縁」として誤認され、一体感を損なう原因になる。シンプルな一枚板を目指すなら、insetシャドウは避け、ボーダーと背景色のみで構成するのが安全である。
- キーボードショートカットによる状態リセットは、マウス操作を挟まずに連続してタスクを行いたいパワーユーザーにとって重要である。`Cmd+Shift+O` のようなリセットショートカットを提供することで、ウィンドウを閉じることなく新しいコンテキストへ移行できる。
- 実装が固まった段階で、仕様書（`要件定義.md` / `デザインUX.md` / `app/README.md`）を同日に同期しておくと、後から見返した時の「どれが真実か」問題を避けられる。特にショートカット（`Cmd+Enter` / `Cmd+Shift+O` / `Escape`）や Hide-on-Blur など体験の核はドキュメント側にも必ず固定する。
- Obsidian Vaultのような同期対象ディレクトリに `node_modules` を置くと、ファイル数増加で検索/同期/バックアップが重くなる。再生成可能な生成物は削除し、`npm install` で復元できる前提にすると秩序を保ちやすい。
- `preload-*.js` のような未使用ファイルが残ると「どれが実際に読み込まれているか」が曖昧になる。実際に使っている拡張子（今回は `.cjs`）だけを残し、不要物は削除する方が保守が楽。
